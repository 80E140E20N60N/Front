<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>防抖和节流</title>
  <style>
    body {
      overflow: scroll;
    }
  </style>
</head>

<body>
  <!-- p{顺序$}*100   快速生成100个标签-->
  <p>顺序1</p>
  <p>顺序2</p>
  <p>顺序3</p>
  <p>顺序4</p>
  <p>顺序5</p>
  <p>顺序6</p>
  <p>顺序7</p>
  <p>顺序8</p>
  <p>顺序9</p>
  <p>顺序10</p>
  <p>顺序11</p>
  <p>顺序12</p>
  <p>顺序13</p>
  <p>顺序14</p>
  <p>顺序15</p>
  <p>顺序16</p>
  <p>顺序17</p>
  <p>顺序18</p>
  <p>顺序19</p>
  <p>顺序20</p>
  <p>顺序21</p>
  <p>顺序22</p>
  <p>顺序23</p>
  <p>顺序24</p>
  <p>顺序25</p>
  <p>顺序26</p>
  <p>顺序27</p>
  <p>顺序28</p>
  <p>顺序29</p>
  <p>顺序30</p>
  <p>顺序31</p>
  <p>顺序32</p>
  <p>顺序33</p>
  <p>顺序34</p>
  <p>顺序35</p>
  <p>顺序36</p>
  <p>顺序37</p>
  <p>顺序38</p>
  <p>顺序39</p>
  <p>顺序40</p>
  <p>顺序41</p>
  <p>顺序42</p>
  <p>顺序43</p>
  <p>顺序44</p>
  <p>顺序45</p>
  <p>顺序46</p>
  <p>顺序47</p>
  <p>顺序48</p>
  <p>顺序49</p>
  <p>顺序50</p>
  <p>顺序51</p>
  <p>顺序52</p>
  <p>顺序53</p>
  <p>顺序54</p>
  <p>顺序55</p>
  <p>顺序56</p>
  <p>顺序57</p>
  <p>顺序58</p>
  <p>顺序59</p>
  <p>顺序60</p>
  <p>顺序61</p>
  <p>顺序62</p>
  <p>顺序63</p>
  <p>顺序64</p>
  <p>顺序65</p>
  <p>顺序66</p>
  <p>顺序67</p>
  <p>顺序68</p>
  <p>顺序69</p>
  <p>顺序70</p>
  <p>顺序71</p>
  <p>顺序72</p>
  <p>顺序73</p>
  <p>顺序74</p>
  <p>顺序75</p>
  <p>顺序76</p>
  <p>顺序77</p>
  <p>顺序78</p>
  <p>顺序79</p>
  <p>顺序80</p>
  <p>顺序81</p>
  <p>顺序82</p>
  <p>顺序83</p>
  <p>顺序84</p>
  <p>顺序85</p>
  <p>顺序86</p>
  <p>顺序87</p>
  <p>顺序88</p>
  <p>顺序89</p>
  <p>顺序90</p>
  <p>顺序91</p>
  <p>顺序92</p>
  <p>顺序93</p>
  <p>顺序94</p>
  <p>顺序95</p>
  <p>顺序96</p>
  <p>顺序97</p>
  <p>顺序98</p>
  <p>顺序99</p>
  <p>顺序100</p>

  <!-- 什么是防抖和节流,有哪些应用场景 -->

  <!-- 防抖    debounce 防止抖动，误操作 -->
  <!-- 实现思路：在第一次触发事件时，不立即执行函数，而是给出一个延时
        当延时时间内没有再次触发该事件，就会执行函数
        当延时时间内再次触发该事件，那么当前计时取消，重新开始计时
  -->
  <!-- 防抖效果：短时间内连续触发相同事件，防抖可以做到在某个时间期限内，函数只执行一次(最后一次) -->

  <!-- 使用防抖，理论上只要一直触发同一事件，那么函数永远不会执行，所以，如果希望即使用户不断触发同一事件，在某个时间间隔后可以执行一次函数，可以使用节流 -->

  <!-- 节流    throttle  节流，压制，减速-->
  <!-- 实现思路：封装一个类似控制阀门一样定期开放有效的函数，即函数执行一次后，在一段时间内暂时失效，直到过了这段时间才生效 -->
  <!-- 节流效果： 短时间内大量触发同一事件，函数在执行一次后，在短时间内不会再工作，直到过了这段时间才生效-->

  <!-- 防抖应用 -->
  <!-- 页面做适配时,需要根据最终呈现的页面情况进行dom渲染（这种情形一般是使用防抖，因为只需要判断最后一次的变化情况 -->

  <!-- 节流应用 -->
  <!-- 输入框input事件  比如实现实时搜索(查询输入文本的相关内容),当输入间隔大于某个时间时，就认为已经输入完成,然后开始搜索 -->



  <!-- 例子：滚动条监听 -->
  <script>
    // 优化前：默认执行频率太高
    function shoeTop() {
      let scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
      console.log('滚动条位置：' + scrollTop);
    }
    // window.onscroll = shoeTop    //优化前 键盘下键一次执行8-9行
    // window.onscroll = debounce(shoeTop, 1000)//防抖 必须等停止滚动1秒后才有打印信息
    window.onscroll = throttle(shoeTop, 1000)//节流 滚动条滚动的过程中每隔1秒会打印信息一次

    // 防抖优化
    function debounce(fn, delay) {
      let timeID = null;
      return function () {
        if (timeID) {
          clearInterval(timeID)
        }
        timeID = setTimeout(fn, delay)
      }
    }

    // 节流优化
    function throttle(fn, delay) {
      let valid = true;
      return function () {
        if (!valid) {
          return false;
        }
        valid = false;
        setTimeout(() => {
          fn();
          valid = true;
        }, delay);
      }
    }
  </script>
</body>

</html>